{
    "docs": [
        {
            "location": "/", 
            "text": "ApplySyntax\n\ue157\n\n\nOverview\n\ue157\n\n\nApplySyntax is a plugin for Sublime Text that allows you to detect and apply the syntax of files that might not otherwise be detected properly. For example, files with the \n.rb\n extension are usually Ruby files, but when they are found in a Rails project, they could be RSpec spec files, Cucumber step files, Ruby on Rails files (controllers, models, etc), or just plain Ruby files. This is actually the problem I was trying to solve when I started working on this plugin.\n\n\nCredits\n\ue157\n\n\nDetectSyntax was originally created by phillipkoebbe.  In his words, these are his credits:\n\n\n\n\nIt all started by forking the plugin created by JeanMertz \n(1)\n. I modified it quite extensively until I ended up with something entirely my own \n(2)\n. @maxim and @omarramos commented on the gist and suggested it should be part of Package Control. As I had created it solely for my own consumption, it seemed a bit \"hard-coded\" to be valuable as a package, but then I took a look at SetSyntax \n(3)\n. and saw how using settings would make it very flexible. That set me on the path that led to DetectSyntax.\n\n\n\n\n \nphillipkoebbe\n\n\nInstallation\n\ue157\n\n\nThe recommended installation method is via Package Control.  Learn more here: \nhttps://sublime.wbond.net/\n.", 
            "title": "About ApplySyntax"
        }, 
        {
            "location": "/#applysyntax", 
            "text": "", 
            "title": "ApplySyntax"
        }, 
        {
            "location": "/#overview", 
            "text": "ApplySyntax is a plugin for Sublime Text that allows you to detect and apply the syntax of files that might not otherwise be detected properly. For example, files with the  .rb  extension are usually Ruby files, but when they are found in a Rails project, they could be RSpec spec files, Cucumber step files, Ruby on Rails files (controllers, models, etc), or just plain Ruby files. This is actually the problem I was trying to solve when I started working on this plugin.", 
            "title": "Overview"
        }, 
        {
            "location": "/#credits", 
            "text": "DetectSyntax was originally created by phillipkoebbe.  In his words, these are his credits:   It all started by forking the plugin created by JeanMertz  (1) . I modified it quite extensively until I ended up with something entirely my own  (2) . @maxim and @omarramos commented on the gist and suggested it should be part of Package Control. As I had created it solely for my own consumption, it seemed a bit \"hard-coded\" to be valuable as a package, but then I took a look at SetSyntax  (3) . and saw how using settings would make it very flexible. That set me on the path that led to DetectSyntax.     phillipkoebbe", 
            "title": "Credits"
        }, 
        {
            "location": "/#installation", 
            "text": "The recommended installation method is via Package Control.  Learn more here:  https://sublime.wbond.net/ .", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\ue157\n\n\nPackage Control\n\ue157\n\n\nThe recommended way to install ApplySyntax is via \nPackage Control\n.  Package Control will install the correct branch on your system and keep it up to date.\n\n\n\n\n\n\n\n\nEnsure Package Control is installed.  Instructions are found \nhere\n.\n\n\n\n\n\n\nIn Sublime Text, press \nCtrl\n\uff0b\nShift\n\uff0b\nP\n (Win, Linux) or \nCmd\n\uff0b\nShift\n\uff0b\nP\n (macOS) to bring up the quick panel and start typing \nPackage Control: Install Package\n.  Select the command and it will show a list of installable plugins.\n\n\n\n\n\n\nStart typing \nApplySyntax\n; when you see it, select it.\n\n\n\n\n\n\nRestart to be sure everything is loaded proper.\n\n\n\n\n\n\nEnjoy!\n\n\n\n\n\n\nManual Installation\n\ue157\n\n\n\n\nWarning\n\n\nThis is not the recommended way to install ApplySyntax for the average user.  Installing this way \nwill not\n get automatically updated.\n\n\nIf you are forking for a pull request, you should \njust\n clone ApplySyntax and run Package Control's \nSatisfy Dependency\n command to get all the dependencies.\n\n\n\n\nFor those who want to install ApplySyntax without package control, here are the steps.  It is understood that some people, for what ever reason, will prefer manual install and may even have legitimate reasons to do so.  When going this route, you will have to keep all the packages updated yourself.\n\n\n\n\n\n\n\n\nDownload the latest releases of the following dependencies and unpack or git clone in the \nPackages\n folder as shown below:\n\n\n\n\nhttps://bitbucket.org/teddy_beer_maniac/sublime-text-dependency-markupsafe\n -\n \nmarkupsafe\n\n\nhttps://bitbucket.org/teddy_beer_maniac/sublime-text-dependency-jinja2\n -\n \npython-jinja2\n\n\nhttps://github.com/packagecontrol/pygments\n -\n \npygments\n\n\nhttps://github.com/facelessuser/sublime-markdown-popups\n -\n \nmdpopups\n\n\nhttps://github.com/facelessuser/sublime-markdown\n -\n \npython-markdown\n\n\n\n\n\n\n\n\nDownload and unpack, or git clone, the latest ApplySyntax release and unpack as \nApplySyntax\n:\n\n\n\n\nhttps://github.com/facelessuser/ApplySyntax\n -\n ApplySyntax\n\n\n\n\n\n\n\n\nCreate a folder under \nPackages\n called \n00-dependencies\n and under that folder create a file called \n00-dependencies.py\n:\n\n\nCopy the following code to \n00-dependencies.py\n (this code was taken from Package Control):\n\n\nimport\n \nsys\n\n\nimport\n \nos\n\n\nfrom\n \nos.path\n \nimport\n \ndirname\n\n\n\nif\n \nos\n.\nname\n \n==\n \nnt\n:\n\n    \nfrom\n \nctypes\n \nimport\n \nwindll\n,\n \ncreate_unicode_buffer\n\n\n\nimport\n \nsublime\n\n\n\n\nif\n \nsys\n.\nversion_info\n \n=\n \n(\n3\n,):\n\n    \ndef\n \ndecode\n(\npath\n):\n\n        \nreturn\n \npath\n\n\n    \ndef\n \nencode\n(\npath\n):\n\n        \nreturn\n \npath\n\n\n    \nif\n \nos\n.\npath\n.\nbasename\n(\n__file__\n)\n \n==\n \nsys_path.py\n:\n\n        \npc_package_path\n \n=\n \ndirname\n(\ndirname\n(\n__file__\n))\n\n    \n# When loaded as a .sublime-package file, the filename ends up being\n\n    \n# Package Control.sublime-package/Package Control.package_control.sys_path\n\n    \nelse\n:\n\n        \npc_package_path\n \n=\n \ndirname\n(\n__file__\n)\n\n    \nst_version\n \n=\n \nu\n3\n\n\n\nelse\n:\n\n    \ndef\n \ndecode\n(\npath\n):\n\n        \nif\n \nnot\n \nisinstance\n(\npath\n,\n \nunicode\n):\n\n            \npath\n \n=\n \npath\n.\ndecode\n(\nsys\n.\ngetfilesystemencoding\n())\n\n        \nreturn\n \npath\n\n\n    \ndef\n \nencode\n(\npath\n):\n\n        \nif\n \nisinstance\n(\npath\n,\n \nunicode\n):\n\n            \npath\n \n=\n \npath\n.\nencode\n(\nsys\n.\ngetfilesystemencoding\n())\n\n        \nreturn\n \npath\n\n\n    \npc_package_path\n \n=\n \ndecode\n(\nos\n.\ngetcwd\n())\n\n    \nst_version\n \n=\n \nu\n2\n\n\n\n\nst_dir\n \n=\n \ndirname\n(\ndirname\n(\npc_package_path\n))\n\n\n\n\ndef\n \nadd\n(\npath\n,\n \nfirst\n=\nFalse\n):\n\n    \n\n\n    Adds an entry to the beginning of sys.path, working around the fact that\n\n\n    Python 2.6 can\nt import from non-ASCII paths on Windows.\n\n\n\n    :param path:\n\n\n        A unicode string of a folder, zip file or sublime-package file to\n\n\n        add to the path\n\n\n\n    :param first:\n\n\n        If the path should be added at the beginning\n\n\n    \n\n\n    \nif\n \nos\n.\nname\n \n==\n \nnt\n:\n\n        \n# Work around unicode path import issue on Windows with Python 2.6\n\n        \nbuf\n \n=\n \ncreate_unicode_buffer\n(\n512\n)\n\n        \nif\n \nwindll\n.\nkernel32\n.\nGetShortPathNameW\n(\npath\n,\n \nbuf\n,\n \nlen\n(\nbuf\n)):\n\n            \npath\n \n=\n \nbuf\n.\nvalue\n\n\n    \nenc_path\n \n=\n \nencode\n(\npath\n)\n\n\n    \nif\n \nos\n.\npath\n.\nexists\n(\nenc_path\n):\n\n        \nif\n \nfirst\n:\n\n            \ntry\n:\n\n                \nsys\n.\npath\n.\nremove\n(\nenc_path\n)\n\n            \nexcept\n \n(\nValueError\n):\n\n                \npass\n\n            \nsys\n.\npath\n.\ninsert\n(\n0\n,\n \nenc_path\n)\n\n        \nelif\n \nenc_path\n \nnot\n \nin\n \nsys\n.\npath\n:\n\n            \nsys\n.\npath\n.\nappend\n(\nenc_path\n)\n\n\n\n\ndef\n \nremove\n(\npath\n):\n\n    \n\n\n    Removes a path from sys.path if it is present\n\n\n\n    :param path:\n\n\n        A unicode string of a folder, zip file or sublime-package file\n\n\n    \n\n\n    \ntry\n:\n\n        \nsys\n.\npath\n.\nremove\n(\nencode\n(\npath\n))\n\n    \nexcept\n \n(\nValueError\n):\n\n        \npass\n\n\n    \nif\n \nos\n.\nname\n \n==\n \nnt\n:\n\n        \nbuf\n \n=\n \ncreate_unicode_buffer\n(\n512\n)\n\n        \nif\n \nwindll\n.\nkernel32\n.\nGetShortPathNameW\n(\npath\n,\n \nbuf\n,\n \nlen\n(\nbuf\n)):\n\n            \npath\n \n=\n \nbuf\n.\nvalue\n\n        \ntry\n:\n\n            \nsys\n.\npath\n.\nremove\n(\nencode\n(\npath\n))\n\n        \nexcept\n \n(\nValueError\n):\n\n            \npass\n\n\n\n\ndef\n \ngenerate_dependency_paths\n(\nname\n):\n\n    \n\n\n    Accepts a dependency name and generates a dict containing the three standard\n\n\n    import paths that are valid for the current machine.\n\n\n\n    :param name:\n\n\n        A unicode string name of the dependency\n\n\n\n    :return:\n\n\n        A dict with the following keys:\n\n\n         - \nver\n\n\n         - \nplat\n\n\n         - \narch\n\n\n    \n\n\n    \npackages_dir\n \n=\n \nos\n.\npath\n.\njoin\n(\nst_dir\n,\n \nu\nPackages\n)\n\n    \ndependency_dir\n \n=\n \nos\n.\npath\n.\njoin\n(\npackages_dir\n,\n \nname\n)\n\n\n    \nver\n \n=\n \nu\nst\n%s\n \n%\n \nst_version\n\n    \nplat\n \n=\n \nsublime\n.\nplatform\n()\n\n    \narch\n \n=\n \nsublime\n.\narch\n()\n\n\n    \nreturn\n \n{\n\n        \nall\n:\n \nos\n.\npath\n.\njoin\n(\ndependency_dir\n,\n \nall\n),\n\n        \nver\n:\n \nos\n.\npath\n.\njoin\n(\ndependency_dir\n,\n \nver\n),\n\n        \nplat\n:\n \nos\n.\npath\n.\njoin\n(\ndependency_dir\n,\n \nu\n%s\n_\n%s\n \n%\n \n(\nver\n,\n \nplat\n)),\n\n        \narch\n:\n \nos\n.\npath\n.\njoin\n(\ndependency_dir\n,\n \nu\n%s\n_\n%s\n_\n%s\n \n%\n \n(\nver\n,\n \nplat\n,\n \narch\n))\n\n    \n}\n\n\n\n\ndef\n \nadd_dependency\n(\nname\n,\n \nfirst\n=\nFalse\n):\n\n    \n\n\n    Accepts a dependency name and automatically adds the appropriate path\n\n\n    to sys.path, if the dependency has a path for the current platform and\n\n\n    architecture.\n\n\n\n    :param name:\n\n\n        A unicode string name of the dependency\n\n\n\n    :param first:\n\n\n        If the path should be added to the beginning of the list\n\n\n    \n\n\n    \ndep_paths\n \n=\n \ngenerate_dependency_paths\n(\nname\n)\n\n\n    \nfor\n \npath\n \nin\n \ndep_paths\n.\nvalues\n():\n\n        \nif\n \nos\n.\npath\n.\nexists\n(\nencode\n(\npath\n)):\n\n            \nadd\n(\npath\n,\n \nfirst\n=\nfirst\n)\n\n\n\n\nadd_dependency\n(\npygments\n)\n\n\nadd_dependency\n(\nmarkupsafe\n)\n\n\nadd_dependency\n(\npython-markdown\n)\n\n\nadd_dependency\n(\npython-jinja2\n)\n\n\nadd_dependency\n(\nmdpopups\n)\n\n\n\n\n\n\n\n\n\nRestart and enjoy.\n\n\n\n\n\n\nGit Cloning\n\ue157\n\n\n\n\n\n\nQuit Sublime Text.\n\n\n\n\n\n\nOpen a terminal and enter the following.  For dependencies, replace the URL with the appropriate URL, and the appropriate folder to check it out to:\n\n\ncd /path/to/Sublime Text 3/Packages\ngit clone https://github.com/facelessuser/ApplySyntax.git ApplySyntax\n\n\n\n\n\n\n\n\nRestart Sublime Text.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#package-control", 
            "text": "The recommended way to install ApplySyntax is via  Package Control .  Package Control will install the correct branch on your system and keep it up to date.     Ensure Package Control is installed.  Instructions are found  here .    In Sublime Text, press  Ctrl \uff0b Shift \uff0b P  (Win, Linux) or  Cmd \uff0b Shift \uff0b P  (macOS) to bring up the quick panel and start typing  Package Control: Install Package .  Select the command and it will show a list of installable plugins.    Start typing  ApplySyntax ; when you see it, select it.    Restart to be sure everything is loaded proper.    Enjoy!", 
            "title": "Package Control"
        }, 
        {
            "location": "/installation/#manual-installation", 
            "text": "Warning  This is not the recommended way to install ApplySyntax for the average user.  Installing this way  will not  get automatically updated.  If you are forking for a pull request, you should  just  clone ApplySyntax and run Package Control's  Satisfy Dependency  command to get all the dependencies.   For those who want to install ApplySyntax without package control, here are the steps.  It is understood that some people, for what ever reason, will prefer manual install and may even have legitimate reasons to do so.  When going this route, you will have to keep all the packages updated yourself.     Download the latest releases of the following dependencies and unpack or git clone in the  Packages  folder as shown below:   https://bitbucket.org/teddy_beer_maniac/sublime-text-dependency-markupsafe  -   markupsafe  https://bitbucket.org/teddy_beer_maniac/sublime-text-dependency-jinja2  -   python-jinja2  https://github.com/packagecontrol/pygments  -   pygments  https://github.com/facelessuser/sublime-markdown-popups  -   mdpopups  https://github.com/facelessuser/sublime-markdown  -   python-markdown     Download and unpack, or git clone, the latest ApplySyntax release and unpack as  ApplySyntax :   https://github.com/facelessuser/ApplySyntax  -  ApplySyntax     Create a folder under  Packages  called  00-dependencies  and under that folder create a file called  00-dependencies.py :  Copy the following code to  00-dependencies.py  (this code was taken from Package Control):  import   sys  import   os  from   os.path   import   dirname  if   os . name   ==   nt : \n     from   ctypes   import   windll ,   create_unicode_buffer  import   sublime  if   sys . version_info   =   ( 3 ,): \n     def   decode ( path ): \n         return   path \n\n     def   encode ( path ): \n         return   path \n\n     if   os . path . basename ( __file__ )   ==   sys_path.py : \n         pc_package_path   =   dirname ( dirname ( __file__ )) \n     # When loaded as a .sublime-package file, the filename ends up being \n     # Package Control.sublime-package/Package Control.package_control.sys_path \n     else : \n         pc_package_path   =   dirname ( __file__ ) \n     st_version   =   u 3  else : \n     def   decode ( path ): \n         if   not   isinstance ( path ,   unicode ): \n             path   =   path . decode ( sys . getfilesystemencoding ()) \n         return   path \n\n     def   encode ( path ): \n         if   isinstance ( path ,   unicode ): \n             path   =   path . encode ( sys . getfilesystemencoding ()) \n         return   path \n\n     pc_package_path   =   decode ( os . getcwd ()) \n     st_version   =   u 2  st_dir   =   dirname ( dirname ( pc_package_path ))  def   add ( path ,   first = False ): \n          Adds an entry to the beginning of sys.path, working around the fact that      Python 2.6 can t import from non-ASCII paths on Windows.      :param path:          A unicode string of a folder, zip file or sublime-package file to          add to the path      :param first:          If the path should be added at the beginning       \n\n     if   os . name   ==   nt : \n         # Work around unicode path import issue on Windows with Python 2.6 \n         buf   =   create_unicode_buffer ( 512 ) \n         if   windll . kernel32 . GetShortPathNameW ( path ,   buf ,   len ( buf )): \n             path   =   buf . value \n\n     enc_path   =   encode ( path ) \n\n     if   os . path . exists ( enc_path ): \n         if   first : \n             try : \n                 sys . path . remove ( enc_path ) \n             except   ( ValueError ): \n                 pass \n             sys . path . insert ( 0 ,   enc_path ) \n         elif   enc_path   not   in   sys . path : \n             sys . path . append ( enc_path )  def   remove ( path ): \n          Removes a path from sys.path if it is present      :param path:          A unicode string of a folder, zip file or sublime-package file       \n\n     try : \n         sys . path . remove ( encode ( path )) \n     except   ( ValueError ): \n         pass \n\n     if   os . name   ==   nt : \n         buf   =   create_unicode_buffer ( 512 ) \n         if   windll . kernel32 . GetShortPathNameW ( path ,   buf ,   len ( buf )): \n             path   =   buf . value \n         try : \n             sys . path . remove ( encode ( path )) \n         except   ( ValueError ): \n             pass  def   generate_dependency_paths ( name ): \n          Accepts a dependency name and generates a dict containing the three standard      import paths that are valid for the current machine.      :param name:          A unicode string name of the dependency      :return:          A dict with the following keys:           -  ver           -  plat           -  arch       \n\n     packages_dir   =   os . path . join ( st_dir ,   u Packages ) \n     dependency_dir   =   os . path . join ( packages_dir ,   name ) \n\n     ver   =   u st %s   %   st_version \n     plat   =   sublime . platform () \n     arch   =   sublime . arch () \n\n     return   { \n         all :   os . path . join ( dependency_dir ,   all ), \n         ver :   os . path . join ( dependency_dir ,   ver ), \n         plat :   os . path . join ( dependency_dir ,   u %s _ %s   %   ( ver ,   plat )), \n         arch :   os . path . join ( dependency_dir ,   u %s _ %s _ %s   %   ( ver ,   plat ,   arch )) \n     }  def   add_dependency ( name ,   first = False ): \n          Accepts a dependency name and automatically adds the appropriate path      to sys.path, if the dependency has a path for the current platform and      architecture.      :param name:          A unicode string name of the dependency      :param first:          If the path should be added to the beginning of the list       \n\n     dep_paths   =   generate_dependency_paths ( name ) \n\n     for   path   in   dep_paths . values (): \n         if   os . path . exists ( encode ( path )): \n             add ( path ,   first = first )  add_dependency ( pygments )  add_dependency ( markupsafe )  add_dependency ( python-markdown )  add_dependency ( python-jinja2 )  add_dependency ( mdpopups )     Restart and enjoy.", 
            "title": "Manual Installation"
        }, 
        {
            "location": "/installation/#git-cloning", 
            "text": "Quit Sublime Text.    Open a terminal and enter the following.  For dependencies, replace the URL with the appropriate URL, and the appropriate folder to check it out to:  cd /path/to/Sublime Text 3/Packages\ngit clone https://github.com/facelessuser/ApplySyntax.git ApplySyntax    Restart Sublime Text.", 
            "title": "Git Cloning"
        }, 
        {
            "location": "/usage/", 
            "text": "User Guide\n\ue157\n\n\nOverview\n\ue157\n\n\nApplySyntax is based on the idea of creating rules for applying certain syntaxes to specific files. You define the rules, the plugin checks them. The first one to pass wins.\n\n\nApplySyntax allows you to create your own custom rules. The easiest way to get started is to create a settings file called \nApplySyntax.sublime-settings\n in your \nPackages/User\n folder.  You can override the default settings in \nPackages/ApplySyntax/ApplySyntax.sublime-settings\n by setting them in your \nPackages/User/ApplySyntax.sublime-settings\n file. You can override any setting to meet your needs.  To prepend rules to the default rule set, you can create a key called \nsyntaxes\n (modifying \ndefault_syntaxes\n will wipe out all the default rules and is not recommended as you won't get the latest updates).\n\n\nCreating Rules\n\ue157\n\n\nEach rule is a dictionary within the syntax array.  Let's take a look at the top level parameters.\n\n\nSyntax\n\ue157\n\n\nThe \nsyntax\n attribute is the syntax file that will be applied to a view which meets the criteria defined in the rule.\n\n\nFor syntax files you must specify the path to the syntax file. The plugin is capable of supporting multiple levels of folder nesting if you need it to. For example, if you had all of your tmLanguage files for Rails organized in a folder like this: \nPackages/Rails/Language/*.tmLanguage\n, and you were looking to use the \nRuby Haml.tmLanguage\n file, the path to name translation would simply be: \nPackages/Rails/Language/Ruby Haml.tmLanguage\n \n \nRails/Language/Ruby Haml\n.\n\n\nsyntax\n:\n \nRails/Language/Ruby Haml\n\n\n\n\n\nNotice that the paths are relative to the \nPackages\n folder.  Also, notice that we don't specify the extension.  Sublime Text in build 3084 added a new language syntax with the extension \nsublime-syntax\n.  In Sublime builds \n= 3084, ApplySyntax will first default to \nsublime-syntax\n and fall back to \ntmLanguage\n if it cannot find the the other format.  If you want to force the syntax, just specify the extension; the extension must be either \nsublime-syntax\n or \ntmLanguage\n.\n\n\nsyntax\n:\n \nRails/Language/Ruby Haml.tmLanguage\n\n\n\n\n\nIf it is desirable for the syntax rule to reference multiple tmLanguage files because it is not known which package will be on a machine, you can set the syntax as an array of syntaxes as shown in the following example.  The first one found will be used.\n\n\nsyntax\n:\n \n[\nRSpec/RSpec\n,\n \nRSpec (snippets and syntax)/Syntaxes/RSpec\n]\n\n\n\n\n\nNotice that each syntax file has a different path since they come from completely different plugins.\n\n\nLastly, if using Package Control, it is likely that most, if not all, of your packages will be zipped with the extension \n.sublime-package\n in the \nInstalled Packages\n folder instead of \nPackages\n.  These will be handled exactly like plugins installed under \nPackages\n.  The one difference is that you treat the zip bundle as a folder without the \n.sublime-package\n extension.  So if we had a syntax file located in a zipped bundle: \nInstalled Packages/Rails.sublime-package/Language/Ruby Haml.tmLanguage\n \n \nRails/Language/Ruby Haml\n.\n\n\nsyntax\n:\n \nRails/Language/Ruby Haml\n\n\n\n\n\n\n\nDeprecation\n\n\nThe previous name for this key was \nname\n and has been deprecated and will be removed in the future.\n\n\n\n\nExtensions\n\ue157\n\n\nThe \nextensions\n attribute is used to define extensions to apply a syntax to.  \nextensions\n is an array of strings where each string is an extension.  No \n.\n is needed when defining extensions, unless it is desired to target a dot file like \n.gitignore\n, then you would include the \n.\n.\n\n\n    \n{\n\n        \nsyntax\n:\n \nYAML/YAML\n,\n\n        \nextensions\n:\n \n[\n.gemrc\n,\n \nyml\n,\n \nyml.dist\n]\n\n    \n},\n\n\n\n\n\nextensions\n is evaluated before all other rules, and it never takes part in \"\nmatch all\n\" rule sets as it is run separate from the normal rule sets; if an extension is matched here, all other rules will be skipped.\n\n\nAn added benefit of \nextensions\n, if you are using \nST3\n and set \nadd_exts_to_lang_settings\n to \ntrue\n, is that ApplySyntax will add the extensions to the specified syntax language's settings file in your \nUser\n folder.  By doing this, Sublime Text will be able to show the associated icon for the file type in the sidebar.  Apply syntax will also create a file \nApplySyntax.ext-list\n in your \nUser\n folder and track which extension it added so that if you remove a rule, ApplySyntax will only remove the extensions it added to the language file in question. If you do not like this functionality, you can simply disable \nadd_exts_to_lang_settings\n by setting it to \nfalse\n.\n\n\n\n\nNote\n\n\nadd_exts_to_lang_settings\n will not be applied to \nextensions\n found in a \nproject specific rule\n, as project specific rules are not global, but the effects of \nadd_exts_to_lang_settings\n are global.\n\n\n\n\nMatch\n\ue157\n\n\nmatch\n is a setting that you either include or omit.  When included, you set it to \nall\n.  When set, all rules defined must be met for a match to be considered successful.  \nmatch\n ignores the \nextensions\n key as \nextensions\n never take part in \"match all\" rule sets.  If you want to include an extension rule in a \"match all\" rule set, then a \nfile_path\n rule should be used.\n\n\n    \nmatch\n:\n \nall\n\n\n\n\n\nSo in this case, all the rules must match for the syntax to be applied:\n\n\n     \nsyntax\n:\n \nHandlebars/Handlebars\n,\n\n     \nmatch\n:\n \nall\n,\n\n     \nrules\n:\n \n[\n\n         \n{\nfile_path\n:\n \n.*\\\\.html$\n},\n\n         \n{\ncontains\n:\n \nscript [^\n]*type=\\\ntext\\\\/x-handlebars\\\n[^\n]*\n}\n\n     \n]\n\n\n\n\n\nIn this case, there is no \nmatch\n key, so only one rule needs to match:\n\n\n    \n{\n\n        \nsyntax\n:\n \nRuby/Ruby\n,\n\n        \nrules\n:\n \n[\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)Gemfile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)Capfile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)Guardfile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)[Rr]akefile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)Berksfile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)[Cc]heffile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)Thorfile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)Podfile$\n},\n\n            \n{\nfile_path\n:\n \n.*(\\\\\\\\|/)config.ru$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\\\\\Vagrantfile(\\\\\\\\..*)?$\n},\n\n            \n{\nfile_path\n:\n \n.*/Vagrantfile(/..*)?$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.thor$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.rake$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.simplecov$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.jbuilder$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.rb$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.podspec$\n},\n\n            \n{\nfile_path\n:\n \n.*\\\\.rabl$\n},\n\n            \n{\ninterpreter\n:\n \nruby\n}\n\n        \n]\n\n    \n},\n\n\n\n\n\nRules\n\ue157\n\n\nrules\n is an array of rules that can be used to target specific files with your defined syntax file.  The rules are processed until the first rule matches, so order your rules in a way that makes sense to you.\n\n\nFile Path Rule\n\ue157\n\n\nA \nfile_path\n rule defines a regex to match against the complete file path. The pattern is always anchored to the beginning of the path, as if there were an implicit \n^\n \u2014 so the pattern \n/a/b/c\n will match the file \n/a/b/c/foo.py\n, but not the file \n/x/y/z/a/b/c/foo.py\n. (You may include an explicit \n^\n at the beginning of the pattern, as some of the default rules do \u2014 but the result is the same either way.)\n\n\nFor backwards compatibility with older versions of ApplySyntax, the rule name \nfile_name\n is also accepted, and functions exactly like \nfile_path\n.\n\n\n{\nfile_path\n:\n \n.*\\\\.xml(\\\\.dist)?$\n},\n\n\n\n\n\n\n\nDeprecation\n\n\nThe previous name for this key was \nfile_name\n and has been deprecated and will be removed in the future.\n\n\n\n\nFirst Line Rule\n\ue157\n\n\nA \nfirst_line\n rule allows you to check whether the first line of the file's content matches a given regex. As with \nfile_path\n \nrules\n, the pattern is always anchored to the beginning of the line.\n\n\n{\nfirst_line\n:\n \n^\n\\\\?xml\n},\n\n\n\n\n\nInterpreter (Shebang)\n\ue157\n\n\nAn \ninterpreter\n rule does the same thing as a \nfirst_line\n rule that uses a regex to match an interpreter directive (shebang).  The difference being that ApplySyntax will construct the regex for you.\n\n\nSo a \nfirst_line\n rule:\n\n\n{\nfirst_line\n:\n \n^#\\\\!(?:.+)ruby\n}\n\n\n\n\n\nCan be simplified as:\n\n\n{\ninterpreter\n:\n \nruby\n}\n\n\n\n\n\nFor backwards compatibility with older versions of ApplySyntax, the rule name \nbinary\n is also accepted, and functions exactly like \ninterpreter\n.\n\n\n\n\nDeprecation\n\n\nThe previous name for this key was \nbinary\n and has been deprecated and will be removed in the future.\n\n\n\n\nFunction Rule\n\ue157\n\n\nThis is an example of using a custom function to decide whether or not to apply a syntax. This is done via ApplySyntax plugins.  The plugin file should be under a plugin folder.\n\n\nThe function rule takes two parameters.  The first is \nsource\n and is the plugin source file.  It is defined as if you were importing a python plugin.  If you had a plugin in \nPackages/ApplySyntax/as_plugins/is_rails_file.py\n, it would be defined under \nsource\n as \nApplySyntax.as_plugins.is_rails_file\n.  Function rules still support the legacy way: \nApplySyntax/as_plugins/is_rails_file\n, but it is recommended to use the dot notation as it makes more sense from a Python import perspective.\n\n\nThe second parameter is \nargs\n and is optional. \nargs\n is a dictionary of the keyword arguments the function rule plugin accepts.\n\n\nThe plugin must have a function defined as \nsyntax_test\n. \nsyntax_test\n will be the function called within the plugin file and accepts an argument \nfile_path\n (which is the full path to the file being evaluated), and any custom keyword arguments desired by the user.  The plugin must return either \nTrue\n or \nFalse\n.\n\n\n{\nfunction\n:\n \n{\nsource\n:\n \nUser.plugins.myplugin\n,\n \nargs\n:\n \n{\nfoo\n:\n \nbar\n}}}\n\n\n\n\n\nExample:\n\n\ndef\n \nsyntax_test\n(\nfile_path\n,\n \nfoo\n):\n\n    \n# Some test logic\n\n    \nreturn\n \nFalse\n \n# True or False\n\n\n\n\n\n\n\nTip\n\n\nWhen placing a function rule module in a package, it is advised to put it in a sub-folder.  The sub-folder does not need an \n__init__.py\n, it just needs your module(s).\n\n\n\n\n\n\nDeprecation\n\n\nPreviously, function rules allowed for a \nname\n attribute which allowed the user to specify the function name to call in the plugin.  In the current version, ApplySyntax looks for a function named \nsyntax_test\n.  While \nname\n is still currently supported, it has been deprecated, and will be removed in the future.\n\n\n\n\nContent Rule\n\ue157\n\n\nSometimes a file name or first line search is just not enough and maybe a function rule is overkill.  In this case, maybe searching the content of a file can be enough.  You can search a file's content with regex for a specific token via the \ncontains\n rule.\n\n\n{\ncontains\n:\n \nscript [^\n]*type=\\\ntext\\\\/x-handlebars\\\n[^\n]*\n}\n\n\n\n\n\n\n\nTip\n\n\nIt is recommended to pair \ncontains\n rules with other rules via the \nmatch\n:\n \nall\n option to ensure you don't search every file (which can significantly slow down the editor); this will also help ensure get more reliable matches. If pairing with other rules as dependencies, it is advised to pair the \ncontains\n rule after the other required rule(s) to ensure you search the content of as few files as possible.\n\n\nAlso, try to use very specific regex to ensure you don't get false positives.\n\n\n\n\nProject Specific Rules\n\ue157\n\n\nTo define project specific syntaxes, just create a \nsettings\n key in your project file (if it doesn't already exist) and then and an additional key under \nsettings\n called \nproject_syntaxes\n.  \nproject_syntaxes\n is an array; just add your syntax rules to \nproject_syntaxes\n just like you would add them to \nsyntaxes\n in your user settings file, and ApplySyntax will prepend the rules to the beginning of your defined rules.  The order of rules is as follows: project \n user \n default.\n\n\nThere is one difference between project specific rules and global rules.  In project rules, the \nextensions\n key will not be applied to the associated syntax language settings file as project specific rules are not global, but language settings files are global.\n\n\n    \nsettings\n:\n \n{\n\n        \nproject_syntaxes\n:\n \n[\n\n            \n{\n\n                \nsyntax\n:\n \nXML/XML\n,\n\n                \nrules\n:\n \n[\n\n                    \n{\nfile_path\n:\n \n.*\\\\.xml(\\\\.dist)?$\n},\n\n                    \n{\nfirst_line\n:\n \n^\n\\\\?xml\n}\n\n                \n]\n\n            \n}\n\n        \n]\n\n    \n}\n\n\n\n\n\nSettings Options\n\ue157\n\n\nThere are a couple of general settings found in \nApplySyntax.sublime-settings\n.\n\n\nRe-Raise Exceptions\n\ue157\n\n\nIf an exception occurs when processing a function, this will re-raised the captured exception in Sublime's console so the user get feedback. This is really only useful to those writing functions. The average user shouldn't need this.  By default, the setting will be set to \nfalse\n.\n\n\n    \nreraise_exceptions\n:\n \nfalse\n,\n\n\n\n\n\nNew File Syntax\n\ue157\n\n\nIf you want to have a syntax applied when new files are created, set \nnew_file_syntax\n to the name of the syntax to use. The format is exactly the same as the \nsyntax\n parameter in the syntax rules mentioned earlier. For example, if you want to have a new file use JavaScript syntax, set \nnew_file_syntax\n to \nJavaScript/JavaScript\n.  The default is \nfalse\n.\n\n\n    \nnew_file_syntax\n:\n \nJavaScript/JavaScript\n,\n\n\n\n\n\nAdd Extensions to Language Settings\n\ue157\n\n\nTo enable adding defined extensions to language settings, just set \nadd_exts_to_lang_settings\n to \ntrue\n.  See \nExtensions\n for more info.\n\n\n    \nadd_exts_to_lang_settings\n:\n \ntrue\n,\n\n\n\n\n\nTroubleshooting and Debugging\n\ue157\n\n\nBy default, the \ndebug\n setting is turned on so that users have some form of visual feedback in the console that ApplySyntax is working.  This can be turned off by setting \ndebug\n to \nfalse\n.  If developing, you can set \ndebug\n to \nverbose\n to get even more info in the console.\n\n\n    \n// Control level of logging in the console.\n\n    \n// (true|false|\nverbose\n)\n\n    \ndebug\n:\n \ntrue\n,", 
            "title": "User Guide"
        }, 
        {
            "location": "/usage/#user-guide", 
            "text": "", 
            "title": "User Guide"
        }, 
        {
            "location": "/usage/#overview", 
            "text": "ApplySyntax is based on the idea of creating rules for applying certain syntaxes to specific files. You define the rules, the plugin checks them. The first one to pass wins.  ApplySyntax allows you to create your own custom rules. The easiest way to get started is to create a settings file called  ApplySyntax.sublime-settings  in your  Packages/User  folder.  You can override the default settings in  Packages/ApplySyntax/ApplySyntax.sublime-settings  by setting them in your  Packages/User/ApplySyntax.sublime-settings  file. You can override any setting to meet your needs.  To prepend rules to the default rule set, you can create a key called  syntaxes  (modifying  default_syntaxes  will wipe out all the default rules and is not recommended as you won't get the latest updates).", 
            "title": "Overview"
        }, 
        {
            "location": "/usage/#creating-rules", 
            "text": "Each rule is a dictionary within the syntax array.  Let's take a look at the top level parameters.", 
            "title": "Creating Rules"
        }, 
        {
            "location": "/usage/#syntax", 
            "text": "The  syntax  attribute is the syntax file that will be applied to a view which meets the criteria defined in the rule.  For syntax files you must specify the path to the syntax file. The plugin is capable of supporting multiple levels of folder nesting if you need it to. For example, if you had all of your tmLanguage files for Rails organized in a folder like this:  Packages/Rails/Language/*.tmLanguage , and you were looking to use the  Ruby Haml.tmLanguage  file, the path to name translation would simply be:  Packages/Rails/Language/Ruby Haml.tmLanguage     Rails/Language/Ruby Haml .  syntax :   Rails/Language/Ruby Haml   Notice that the paths are relative to the  Packages  folder.  Also, notice that we don't specify the extension.  Sublime Text in build 3084 added a new language syntax with the extension  sublime-syntax .  In Sublime builds  = 3084, ApplySyntax will first default to  sublime-syntax  and fall back to  tmLanguage  if it cannot find the the other format.  If you want to force the syntax, just specify the extension; the extension must be either  sublime-syntax  or  tmLanguage .  syntax :   Rails/Language/Ruby Haml.tmLanguage   If it is desirable for the syntax rule to reference multiple tmLanguage files because it is not known which package will be on a machine, you can set the syntax as an array of syntaxes as shown in the following example.  The first one found will be used.  syntax :   [ RSpec/RSpec ,   RSpec (snippets and syntax)/Syntaxes/RSpec ]   Notice that each syntax file has a different path since they come from completely different plugins.  Lastly, if using Package Control, it is likely that most, if not all, of your packages will be zipped with the extension  .sublime-package  in the  Installed Packages  folder instead of  Packages .  These will be handled exactly like plugins installed under  Packages .  The one difference is that you treat the zip bundle as a folder without the  .sublime-package  extension.  So if we had a syntax file located in a zipped bundle:  Installed Packages/Rails.sublime-package/Language/Ruby Haml.tmLanguage     Rails/Language/Ruby Haml .  syntax :   Rails/Language/Ruby Haml    Deprecation  The previous name for this key was  name  and has been deprecated and will be removed in the future.", 
            "title": "Syntax"
        }, 
        {
            "location": "/usage/#extensions", 
            "text": "The  extensions  attribute is used to define extensions to apply a syntax to.   extensions  is an array of strings where each string is an extension.  No  .  is needed when defining extensions, unless it is desired to target a dot file like  .gitignore , then you would include the  . .       { \n         syntax :   YAML/YAML , \n         extensions :   [ .gemrc ,   yml ,   yml.dist ] \n     },   extensions  is evaluated before all other rules, and it never takes part in \" match all \" rule sets as it is run separate from the normal rule sets; if an extension is matched here, all other rules will be skipped.  An added benefit of  extensions , if you are using  ST3  and set  add_exts_to_lang_settings  to  true , is that ApplySyntax will add the extensions to the specified syntax language's settings file in your  User  folder.  By doing this, Sublime Text will be able to show the associated icon for the file type in the sidebar.  Apply syntax will also create a file  ApplySyntax.ext-list  in your  User  folder and track which extension it added so that if you remove a rule, ApplySyntax will only remove the extensions it added to the language file in question. If you do not like this functionality, you can simply disable  add_exts_to_lang_settings  by setting it to  false .   Note  add_exts_to_lang_settings  will not be applied to  extensions  found in a  project specific rule , as project specific rules are not global, but the effects of  add_exts_to_lang_settings  are global.", 
            "title": "Extensions"
        }, 
        {
            "location": "/usage/#match", 
            "text": "match  is a setting that you either include or omit.  When included, you set it to  all .  When set, all rules defined must be met for a match to be considered successful.   match  ignores the  extensions  key as  extensions  never take part in \"match all\" rule sets.  If you want to include an extension rule in a \"match all\" rule set, then a  file_path  rule should be used.       match :   all   So in this case, all the rules must match for the syntax to be applied:        syntax :   Handlebars/Handlebars , \n      match :   all , \n      rules :   [ \n          { file_path :   .*\\\\.html$ }, \n          { contains :   script [^ ]*type=\\ text\\\\/x-handlebars\\ [^ ]* } \n      ]   In this case, there is no  match  key, so only one rule needs to match:       { \n         syntax :   Ruby/Ruby , \n         rules :   [ \n             { file_path :   .*(\\\\\\\\|/)Gemfile$ }, \n             { file_path :   .*(\\\\\\\\|/)Capfile$ }, \n             { file_path :   .*(\\\\\\\\|/)Guardfile$ }, \n             { file_path :   .*(\\\\\\\\|/)[Rr]akefile$ }, \n             { file_path :   .*(\\\\\\\\|/)Berksfile$ }, \n             { file_path :   .*(\\\\\\\\|/)[Cc]heffile$ }, \n             { file_path :   .*(\\\\\\\\|/)Thorfile$ }, \n             { file_path :   .*(\\\\\\\\|/)Podfile$ }, \n             { file_path :   .*(\\\\\\\\|/)config.ru$ }, \n             { file_path :   .*\\\\\\\\Vagrantfile(\\\\\\\\..*)?$ }, \n             { file_path :   .*/Vagrantfile(/..*)?$ }, \n             { file_path :   .*\\\\.thor$ }, \n             { file_path :   .*\\\\.rake$ }, \n             { file_path :   .*\\\\.simplecov$ }, \n             { file_path :   .*\\\\.jbuilder$ }, \n             { file_path :   .*\\\\.rb$ }, \n             { file_path :   .*\\\\.podspec$ }, \n             { file_path :   .*\\\\.rabl$ }, \n             { interpreter :   ruby } \n         ] \n     },", 
            "title": "Match"
        }, 
        {
            "location": "/usage/#rules", 
            "text": "rules  is an array of rules that can be used to target specific files with your defined syntax file.  The rules are processed until the first rule matches, so order your rules in a way that makes sense to you.", 
            "title": "Rules"
        }, 
        {
            "location": "/usage/#file-path-rule", 
            "text": "A  file_path  rule defines a regex to match against the complete file path. The pattern is always anchored to the beginning of the path, as if there were an implicit  ^  \u2014 so the pattern  /a/b/c  will match the file  /a/b/c/foo.py , but not the file  /x/y/z/a/b/c/foo.py . (You may include an explicit  ^  at the beginning of the pattern, as some of the default rules do \u2014 but the result is the same either way.)  For backwards compatibility with older versions of ApplySyntax, the rule name  file_name  is also accepted, and functions exactly like  file_path .  { file_path :   .*\\\\.xml(\\\\.dist)?$ },    Deprecation  The previous name for this key was  file_name  and has been deprecated and will be removed in the future.", 
            "title": "File Path Rule"
        }, 
        {
            "location": "/usage/#first-line-rule", 
            "text": "A  first_line  rule allows you to check whether the first line of the file's content matches a given regex. As with  file_path   rules , the pattern is always anchored to the beginning of the line.  { first_line :   ^ \\\\?xml },", 
            "title": "First Line Rule"
        }, 
        {
            "location": "/usage/#interpreter-shebang", 
            "text": "An  interpreter  rule does the same thing as a  first_line  rule that uses a regex to match an interpreter directive (shebang).  The difference being that ApplySyntax will construct the regex for you.  So a  first_line  rule:  { first_line :   ^#\\\\!(?:.+)ruby }   Can be simplified as:  { interpreter :   ruby }   For backwards compatibility with older versions of ApplySyntax, the rule name  binary  is also accepted, and functions exactly like  interpreter .   Deprecation  The previous name for this key was  binary  and has been deprecated and will be removed in the future.", 
            "title": "Interpreter (Shebang)"
        }, 
        {
            "location": "/usage/#function-rule", 
            "text": "This is an example of using a custom function to decide whether or not to apply a syntax. This is done via ApplySyntax plugins.  The plugin file should be under a plugin folder.  The function rule takes two parameters.  The first is  source  and is the plugin source file.  It is defined as if you were importing a python plugin.  If you had a plugin in  Packages/ApplySyntax/as_plugins/is_rails_file.py , it would be defined under  source  as  ApplySyntax.as_plugins.is_rails_file .  Function rules still support the legacy way:  ApplySyntax/as_plugins/is_rails_file , but it is recommended to use the dot notation as it makes more sense from a Python import perspective.  The second parameter is  args  and is optional.  args  is a dictionary of the keyword arguments the function rule plugin accepts.  The plugin must have a function defined as  syntax_test .  syntax_test  will be the function called within the plugin file and accepts an argument  file_path  (which is the full path to the file being evaluated), and any custom keyword arguments desired by the user.  The plugin must return either  True  or  False .  { function :   { source :   User.plugins.myplugin ,   args :   { foo :   bar }}}   Example:  def   syntax_test ( file_path ,   foo ): \n     # Some test logic \n     return   False   # True or False    Tip  When placing a function rule module in a package, it is advised to put it in a sub-folder.  The sub-folder does not need an  __init__.py , it just needs your module(s).    Deprecation  Previously, function rules allowed for a  name  attribute which allowed the user to specify the function name to call in the plugin.  In the current version, ApplySyntax looks for a function named  syntax_test .  While  name  is still currently supported, it has been deprecated, and will be removed in the future.", 
            "title": "Function Rule"
        }, 
        {
            "location": "/usage/#content-rule", 
            "text": "Sometimes a file name or first line search is just not enough and maybe a function rule is overkill.  In this case, maybe searching the content of a file can be enough.  You can search a file's content with regex for a specific token via the  contains  rule.  { contains :   script [^ ]*type=\\ text\\\\/x-handlebars\\ [^ ]* }    Tip  It is recommended to pair  contains  rules with other rules via the  match :   all  option to ensure you don't search every file (which can significantly slow down the editor); this will also help ensure get more reliable matches. If pairing with other rules as dependencies, it is advised to pair the  contains  rule after the other required rule(s) to ensure you search the content of as few files as possible.  Also, try to use very specific regex to ensure you don't get false positives.", 
            "title": "Content Rule"
        }, 
        {
            "location": "/usage/#project-specific-rules", 
            "text": "To define project specific syntaxes, just create a  settings  key in your project file (if it doesn't already exist) and then and an additional key under  settings  called  project_syntaxes .   project_syntaxes  is an array; just add your syntax rules to  project_syntaxes  just like you would add them to  syntaxes  in your user settings file, and ApplySyntax will prepend the rules to the beginning of your defined rules.  The order of rules is as follows: project   user   default.  There is one difference between project specific rules and global rules.  In project rules, the  extensions  key will not be applied to the associated syntax language settings file as project specific rules are not global, but language settings files are global.       settings :   { \n         project_syntaxes :   [ \n             { \n                 syntax :   XML/XML , \n                 rules :   [ \n                     { file_path :   .*\\\\.xml(\\\\.dist)?$ }, \n                     { first_line :   ^ \\\\?xml } \n                 ] \n             } \n         ] \n     }", 
            "title": "Project Specific Rules"
        }, 
        {
            "location": "/usage/#settings-options", 
            "text": "There are a couple of general settings found in  ApplySyntax.sublime-settings .", 
            "title": "Settings Options"
        }, 
        {
            "location": "/usage/#re-raise-exceptions", 
            "text": "If an exception occurs when processing a function, this will re-raised the captured exception in Sublime's console so the user get feedback. This is really only useful to those writing functions. The average user shouldn't need this.  By default, the setting will be set to  false .       reraise_exceptions :   false ,", 
            "title": "Re-Raise Exceptions"
        }, 
        {
            "location": "/usage/#new-file-syntax", 
            "text": "If you want to have a syntax applied when new files are created, set  new_file_syntax  to the name of the syntax to use. The format is exactly the same as the  syntax  parameter in the syntax rules mentioned earlier. For example, if you want to have a new file use JavaScript syntax, set  new_file_syntax  to  JavaScript/JavaScript .  The default is  false .       new_file_syntax :   JavaScript/JavaScript ,", 
            "title": "New File Syntax"
        }, 
        {
            "location": "/usage/#add-extensions-to-language-settings", 
            "text": "To enable adding defined extensions to language settings, just set  add_exts_to_lang_settings  to  true .  See  Extensions  for more info.       add_exts_to_lang_settings :   true ,", 
            "title": "Add Extensions to Language Settings"
        }, 
        {
            "location": "/usage/#troubleshooting-and-debugging", 
            "text": "By default, the  debug  setting is turned on so that users have some form of visual feedback in the console that ApplySyntax is working.  This can be turned off by setting  debug  to  false .  If developing, you can set  debug  to  verbose  to get even more info in the console.       // Control level of logging in the console. \n     // (true|false| verbose ) \n     debug :   true ,", 
            "title": "Troubleshooting and Debugging"
        }, 
        {
            "location": "/contributing/", 
            "text": "Contributing \n Support\n\ue157\n\n\nOverview\n\ue157\n\n\n\n\n\n\n\n\nSublime Versions\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nST2\n=\nversion\nST3\n\n\nSupported on a separate branch, but not actively.  Any further fixes or enhancements must come from the community.  Issues for versions less than \nST3\n will not be addressed moving forward by me.  Pull requests are welcome for back-porting features, enhancements, or fixes to the old branch, but the content of the pull \nmust\n already exist on the main, actively developed branch.  I will not allow an older branch to exceed the main branch in regards to functionality.\n\n\n\n\n\n\nST3\n\n\nFully supported and actively maintained.\n\n\n\n\n\n\n\n\nContribution from the community is encouraged and can be done in a variety of ways:\n\n\n\n\nBug reports.\n\n\nReviewing code.\n\n\nCode patches via pull requests.\n\n\nDocumentation improvements via pull requests.\n\n\n\n\nBug Reports\n\ue157\n\n\n\n\n\n\nPlease \nread the documentation\n and \nsearch the issue tracker\n to try to find the answer to your question \nbefore\n posting an issue.\n\n\n\n\n\n\nWhen creating an issue on the repository, please provide as much info as possible:\n\n\n\n\nProvide environment information by running \nPreferences-\nPackage Settings-\nApplySyntax-\nSupport Info\n.  The information will be copied to the clipboard; paste the info in issue.\n\n\nErrors in console.\n\n\nDetailed description of the problem.\n\n\nExamples for reproducing the error.  You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format as well for easy copy/paste.\n\n\n\n\nThe more info provided the greater the chance someone will take the time to answer, implement, or fix the issue.\n\n\n\n\n\n\nBe prepared to answer questions and provide additional information if required.  Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.\n\n\n\n\n\n\nReviewing Code\n\ue157\n\n\nTake part in reviewing pull requests and/or reviewing direct commits.  Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.\n\n\nPull Requests\n\ue157\n\n\nPull requests are welcome, and if you plan on contributing directly to the code, there are a couple of things to be mindful of.\n\n\n\n\n\n\nPlease describe the change in as much detail as possible so I can understand what is being added or modified.\n\n\n\n\n\n\nIf you are solving a bug that does not already have an issue, please describe the bug in detail and provide info on how to reproduce if applicable (this is good for me and others to reference later when verifying the issue has been resolved).\n\n\n\n\n\n\nPlease reference and link related open bugs or feature requests in this pull if applicable.\n\n\n\n\n\n\nMake sure you've documented or updated the existing documentation if introducing a new feature or modifying the behavior of an existing feature that a user needs to be aware of.  I will not accept new features or changes to existing features if you have not provided documentation describing the feature.\n\n\n\n\n\n\nContinuous integration tests on are run on all pull requests and commits via Travis CI.  When making a pull request, the tests will automatically be run, and the request must pass to be accepted.  You can (and should) run these tests before pull requesting.  If it is not possible to run these tests locally, they will be run when the pull request is made, but it is strongly suggested that requesters make an effort to verify before requesting to allow for a quick, smooth merge.\n\n\nRunning Validation Tests\n\ue157\n\n\n\n\nTip\n\n\nIf you are running Sublime on a macOS or Linux/Unix system, you run all tests by by running the shell script (assuming you have installed your environment fulfills all requirements below):\n\n\nchmod +x run_tests.sh\n./run_tests.sh\n\n\n\n\n\n\nThere are a couple of dependencies that must be present before running the tests.\n\n\n\n\n\n\nAs \nST3\n is the only current, actively supported version, Python 3.3 must be used to validate the tests.\n\n\n\n\n\n\nUnit tests are run with \npytest\n.  You can install \npytest\n via:\n\n\npip install pytest\n\n\n\n\nThe tests should be run from the root folder of the plugin by using the following command:\n\n\npy.test .\n\n\n\n\n\n\n\n\nLinting is performed on the entire project with \nflake8\n, \nflake8_docstrings\n, \npep8-naming\n.  These can be installed via:\n\n\npip install flake8\npip install flake8_docstrings\npip install pep8-naming\n\n\n\n\nLinting is performed with the following command:\n\n\nflake8 .\n\n\n\n\n\n\n\n\nDocumentation Improvements\n\ue157\n\n\nA ton of time has been spent not only creating and supporting this plugin, but also spent making this documentation.  If you feel it is still lacking, show your appreciation for the plugin by helping to improve the documentation.  Help with documentation is always appreciated and can be done via pull requests.  There shouldn't be any need to run validation tests if only updating documentation.\n\n\nYou don't have to render the docs locally before pull requesting, but if you wish to, I currently use a combination of \nMkDocs\n, the \nMaterial theme\n, and \nPyMdown Extensions\n to render the docs.  You can preview the docs if you install these two packages.  The command for previewing the docs is \nmkdocs serve\n from the root directory. You can then view the documents at \nlocalhost:8000\n.", 
            "title": "Contributing &amp; Support"
        }, 
        {
            "location": "/contributing/#contributing--support", 
            "text": "", 
            "title": "Contributing &amp; Support"
        }, 
        {
            "location": "/contributing/#overview", 
            "text": "Sublime Versions  Description      ST2 = version ST3  Supported on a separate branch, but not actively.  Any further fixes or enhancements must come from the community.  Issues for versions less than  ST3  will not be addressed moving forward by me.  Pull requests are welcome for back-porting features, enhancements, or fixes to the old branch, but the content of the pull  must  already exist on the main, actively developed branch.  I will not allow an older branch to exceed the main branch in regards to functionality.    ST3  Fully supported and actively maintained.     Contribution from the community is encouraged and can be done in a variety of ways:   Bug reports.  Reviewing code.  Code patches via pull requests.  Documentation improvements via pull requests.", 
            "title": "Overview"
        }, 
        {
            "location": "/contributing/#bug-reports", 
            "text": "Please  read the documentation  and  search the issue tracker  to try to find the answer to your question  before  posting an issue.    When creating an issue on the repository, please provide as much info as possible:   Provide environment information by running  Preferences- Package Settings- ApplySyntax- Support Info .  The information will be copied to the clipboard; paste the info in issue.  Errors in console.  Detailed description of the problem.  Examples for reproducing the error.  You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format as well for easy copy/paste.   The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue.    Be prepared to answer questions and provide additional information if required.  Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.", 
            "title": "Bug Reports"
        }, 
        {
            "location": "/contributing/#reviewing-code", 
            "text": "Take part in reviewing pull requests and/or reviewing direct commits.  Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.", 
            "title": "Reviewing Code"
        }, 
        {
            "location": "/contributing/#pull-requests", 
            "text": "Pull requests are welcome, and if you plan on contributing directly to the code, there are a couple of things to be mindful of.    Please describe the change in as much detail as possible so I can understand what is being added or modified.    If you are solving a bug that does not already have an issue, please describe the bug in detail and provide info on how to reproduce if applicable (this is good for me and others to reference later when verifying the issue has been resolved).    Please reference and link related open bugs or feature requests in this pull if applicable.    Make sure you've documented or updated the existing documentation if introducing a new feature or modifying the behavior of an existing feature that a user needs to be aware of.  I will not accept new features or changes to existing features if you have not provided documentation describing the feature.    Continuous integration tests on are run on all pull requests and commits via Travis CI.  When making a pull request, the tests will automatically be run, and the request must pass to be accepted.  You can (and should) run these tests before pull requesting.  If it is not possible to run these tests locally, they will be run when the pull request is made, but it is strongly suggested that requesters make an effort to verify before requesting to allow for a quick, smooth merge.", 
            "title": "Pull Requests"
        }, 
        {
            "location": "/contributing/#running-validation-tests", 
            "text": "Tip  If you are running Sublime on a macOS or Linux/Unix system, you run all tests by by running the shell script (assuming you have installed your environment fulfills all requirements below):  chmod +x run_tests.sh\n./run_tests.sh   There are a couple of dependencies that must be present before running the tests.    As  ST3  is the only current, actively supported version, Python 3.3 must be used to validate the tests.    Unit tests are run with  pytest .  You can install  pytest  via:  pip install pytest  The tests should be run from the root folder of the plugin by using the following command:  py.test .    Linting is performed on the entire project with  flake8 ,  flake8_docstrings ,  pep8-naming .  These can be installed via:  pip install flake8\npip install flake8_docstrings\npip install pep8-naming  Linting is performed with the following command:  flake8 .", 
            "title": "Running Validation Tests"
        }, 
        {
            "location": "/contributing/#documentation-improvements", 
            "text": "A ton of time has been spent not only creating and supporting this plugin, but also spent making this documentation.  If you feel it is still lacking, show your appreciation for the plugin by helping to improve the documentation.  Help with documentation is always appreciated and can be done via pull requests.  There shouldn't be any need to run validation tests if only updating documentation.  You don't have to render the docs locally before pull requesting, but if you wish to, I currently use a combination of  MkDocs , the  Material theme , and  PyMdown Extensions  to render the docs.  You can preview the docs if you install these two packages.  The command for previewing the docs is  mkdocs serve  from the root directory. You can then view the documents at  localhost:8000 .", 
            "title": "Documentation Improvements"
        }
    ]
}